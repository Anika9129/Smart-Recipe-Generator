{"ast":null,"code":"// Import the local recipes data\nimport recipesData from '../database/recipes.json';\nclass RecipeService {\n  constructor() {\n    this.recipes = recipesData.recipes || [];\n  }\n  async getAllRecipes(limit = null, page = 1) {\n    try {\n      let recipes = [...this.recipes];\n      if (limit) {\n        const startIndex = (page - 1) * limit;\n        recipes = recipes.slice(startIndex, startIndex + limit);\n      }\n      return {\n        recipes,\n        total: this.recipes.length,\n        page,\n        totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1\n      };\n    } catch (error) {\n      console.error('Error fetching recipes:', error);\n      throw new Error('Failed to fetch recipes');\n    }\n  }\n  async getRecipeById(id) {\n    try {\n      const recipe = this.recipes.find(r => r.id === parseInt(id));\n      if (!recipe) {\n        throw new Error('Recipe not found');\n      }\n      return {\n        recipe\n      };\n    } catch (error) {\n      console.error('Error fetching recipe:', error);\n      throw new Error('Failed to fetch recipe');\n    }\n  }\n  async searchByIngredients(ingredients, exactMatch = false) {\n    try {\n      const searchTerms = ingredients.map(ing => ing.toLowerCase());\n      const matchedRecipes = this.recipes.filter(recipe => {\n        const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n        if (exactMatch) {\n          return searchTerms.every(term => recipeIngredients.some(ing => ing.includes(term)));\n        } else {\n          return searchTerms.some(term => recipeIngredients.some(ing => ing.includes(term)));\n        }\n      });\n      return {\n        recipes: matchedRecipes,\n        total: matchedRecipes.length\n      };\n    } catch (error) {\n      console.error('Error searching recipes:', error);\n      throw new Error('Failed to search recipes');\n    }\n  }\n  async filterRecipes(filters) {\n    try {\n      let filteredRecipes = [...this.recipes];\n\n      // Filter by dietary preferences\n      if (filters.dietary && filters.dietary.length > 0) {\n        filteredRecipes = filteredRecipes.filter(recipe => filters.dietary.some(diet => recipe.dietary && recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n      }\n\n      // Filter by difficulty\n      if (filters.difficulty) {\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase());\n      }\n\n      // Filter by max cooking time\n      if (filters.maxCookingTime) {\n        const maxTime = parseInt(filters.maxCookingTime);\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.cookingTime && recipe.cookingTime <= maxTime);\n      }\n\n      // Filter by max calories\n      if (filters.maxCalories) {\n        const maxCals = parseInt(filters.maxCalories);\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.nutrition && recipe.nutrition.calories <= maxCals);\n      }\n\n      // Filter by cuisine\n      if (filters.cuisine) {\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase()));\n      }\n      return {\n        recipes: filteredRecipes,\n        total: filteredRecipes.length\n      };\n    } catch (error) {\n      console.error('Error filtering recipes:', error);\n      throw new Error('Failed to filter recipes');\n    }\n  }\n  async rateRecipe(recipeId, rating, userId = 'anonymous') {\n    try {\n      const response = await axios.post(`${API_BASE_URL}/recipes/${recipeId}/rate`, {\n        rating,\n        userId\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error rating recipe:', error);\n      throw new Error('Failed to rate recipe');\n    }\n  }\n  async getRecommendations(availableIngredients = [], dietaryPreferences = [], limit = 5) {\n    try {\n      const response = await axios.post(`${API_BASE_URL}/recipes/recommendations`, {\n        availableIngredients,\n        dietaryPreferences,\n        limit\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting recommendations:', error);\n      throw new Error('Failed to get recommendations');\n    }\n  }\n  async getIngredientSuggestions(input) {\n    try {\n      const response = await axios.get(`${API_BASE_URL}/ingredients/suggestions`, {\n        params: {\n          input\n        }\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting ingredient suggestions:', error);\n      return {\n        suggestions: []\n      };\n    }\n  }\n}\nexport const recipeService = new RecipeService();","map":{"version":3,"names":["recipesData","RecipeService","constructor","recipes","getAllRecipes","limit","page","startIndex","slice","total","length","totalPages","Math","ceil","error","console","Error","getRecipeById","id","recipe","find","r","parseInt","searchByIngredients","ingredients","exactMatch","searchTerms","map","ing","toLowerCase","matchedRecipes","filter","recipeIngredients","name","every","term","some","includes","filterRecipes","filters","filteredRecipes","dietary","diet","recipeDiet","difficulty","maxCookingTime","maxTime","cookingTime","maxCalories","maxCals","nutrition","calories","cuisine","rateRecipe","recipeId","rating","userId","response","axios","post","API_BASE_URL","data","getRecommendations","availableIngredients","dietaryPreferences","getIngredientSuggestions","input","get","params","suggestions","recipeService"],"sources":["C:/Users/singh/OneDrive/Desktop/daffodil/smart-recipe-generator/frontend/src/services/recipeService.js"],"sourcesContent":["// Import the local recipes data\r\nimport recipesData from '../database/recipes.json';\r\n\r\nclass RecipeService {\r\n  constructor() {\r\n    this.recipes = recipesData.recipes || [];\r\n  }\r\n\r\n  async getAllRecipes(limit = null, page = 1) {\r\n    try {\r\n      let recipes = [...this.recipes];\r\n      \r\n      if (limit) {\r\n        const startIndex = (page - 1) * limit;\r\n        recipes = recipes.slice(startIndex, startIndex + limit);\r\n      }\r\n      \r\n      return {\r\n        recipes,\r\n        total: this.recipes.length,\r\n        page,\r\n        totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching recipes:', error);\r\n      throw new Error('Failed to fetch recipes');\r\n    }\r\n  }\r\n\r\n  async getRecipeById(id) {\r\n    try {\r\n      const recipe = this.recipes.find(r => r.id === parseInt(id));\r\n      if (!recipe) {\r\n        throw new Error('Recipe not found');\r\n      }\r\n      return { recipe };\r\n    } catch (error) {\r\n      console.error('Error fetching recipe:', error);\r\n      throw new Error('Failed to fetch recipe');\r\n    }\r\n  }\r\n\r\n  async searchByIngredients(ingredients, exactMatch = false) {\r\n    try {\r\n      const searchTerms = ingredients.map(ing => ing.toLowerCase());\r\n      \r\n      const matchedRecipes = this.recipes.filter(recipe => {\r\n        const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\r\n        \r\n        if (exactMatch) {\r\n          return searchTerms.every(term => \r\n            recipeIngredients.some(ing => ing.includes(term))\r\n          );\r\n        } else {\r\n          return searchTerms.some(term => \r\n            recipeIngredients.some(ing => ing.includes(term))\r\n          );\r\n        }\r\n      });\r\n      \r\n      return {\r\n        recipes: matchedRecipes,\r\n        total: matchedRecipes.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error searching recipes:', error);\r\n      throw new Error('Failed to search recipes');\r\n    }\r\n  }\r\n\r\n  async filterRecipes(filters) {\r\n    try {\r\n      let filteredRecipes = [...this.recipes];\r\n      \r\n      // Filter by dietary preferences\r\n      if (filters.dietary && filters.dietary.length > 0) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          filters.dietary.some(diet => \r\n            recipe.dietary && recipe.dietary.some(recipeDiet => \r\n              recipeDiet.toLowerCase() === diet.toLowerCase()\r\n            )\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Filter by difficulty\r\n      if (filters.difficulty) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase()\r\n        );\r\n      }\r\n      \r\n      // Filter by max cooking time\r\n      if (filters.maxCookingTime) {\r\n        const maxTime = parseInt(filters.maxCookingTime);\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.cookingTime && recipe.cookingTime <= maxTime\r\n        );\r\n      }\r\n      \r\n      // Filter by max calories\r\n      if (filters.maxCalories) {\r\n        const maxCals = parseInt(filters.maxCalories);\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.nutrition && recipe.nutrition.calories <= maxCals\r\n        );\r\n      }\r\n      \r\n      // Filter by cuisine\r\n      if (filters.cuisine) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase())\r\n        );\r\n      }\r\n      \r\n      return {\r\n        recipes: filteredRecipes,\r\n        total: filteredRecipes.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error filtering recipes:', error);\r\n      throw new Error('Failed to filter recipes');\r\n    }\r\n  }\r\n\r\n  async rateRecipe(recipeId, rating, userId = 'anonymous') {\r\n    try {\r\n      const response = await axios.post(`${API_BASE_URL}/recipes/${recipeId}/rate`, {\r\n        rating,\r\n        userId\r\n      });\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error rating recipe:', error);\r\n      throw new Error('Failed to rate recipe');\r\n    }\r\n  }\r\n\r\n  async getRecommendations(availableIngredients = [], dietaryPreferences = [], limit = 5) {\r\n    try {\r\n      const response = await axios.post(`${API_BASE_URL}/recipes/recommendations`, {\r\n        availableIngredients,\r\n        dietaryPreferences,\r\n        limit\r\n      });\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error getting recommendations:', error);\r\n      throw new Error('Failed to get recommendations');\r\n    }\r\n  }\r\n\r\n  async getIngredientSuggestions(input) {\r\n    try {\r\n      const response = await axios.get(`${API_BASE_URL}/ingredients/suggestions`, {\r\n        params: { input }\r\n      });\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Error getting ingredient suggestions:', error);\r\n      return { suggestions: [] };\r\n    }\r\n  }\r\n}\r\n\r\nexport const recipeService = new RecipeService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}