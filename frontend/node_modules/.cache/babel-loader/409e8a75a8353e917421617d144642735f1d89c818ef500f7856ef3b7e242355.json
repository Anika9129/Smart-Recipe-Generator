{"ast":null,"code":"import axios from 'axios';\nclass RecipeService {\n  constructor() {\n    this.recipes = [];\n  }\n  async loadRecipes() {\n    if (this.recipes.length === 0) {\n      try {\n        const response = await axios.get('/recipes.json');\n        this.recipes = response.data.recipes || [];\n      } catch (error) {\n        console.error('Error loading recipes:', error);\n        this.recipes = [];\n      }\n    }\n  }\n  async getAllRecipes(limit = null, page = 1) {\n    await this.loadRecipes();\n    let recipes = [...this.recipes];\n    if (limit) {\n      const startIndex = (page - 1) * limit;\n      recipes = recipes.slice(startIndex, startIndex + limit);\n    }\n    return {\n      recipes,\n      total: this.recipes.length,\n      page,\n      totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1\n    };\n  }\n  async getRecipeById(id) {\n    await this.loadRecipes();\n    const recipe = this.recipes.find(r => r.id === parseInt(id));\n    if (!recipe) {\n      throw new Error('Recipe not found');\n    }\n    return {\n      recipe\n    };\n  }\n  async searchByIngredients(ingredients, exactMatch = false) {\n    await this.loadRecipes();\n    const searchTerms = ingredients.map(ing => ing.toLowerCase());\n    const matchedRecipes = this.recipes.filter(recipe => {\n      const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n      if (exactMatch) {\n        return searchTerms.every(term => recipeIngredients.some(ing => ing.includes(term)));\n      } else {\n        return searchTerms.some(term => recipeIngredients.some(ing => ing.includes(term)));\n      }\n    });\n    return {\n      recipes: matchedRecipes,\n      total: matchedRecipes.length\n    };\n  }\n  async filterRecipes(filters) {\n    await this.loadRecipes();\n    let filteredRecipes = [...this.recipes];\n    // ... (rest of the filtering logic is the same as before)\n    if (filters.dietary && filters.dietary.length > 0) {\n      filteredRecipes = filteredRecipes.filter(recipe => filters.dietary.some(diet => recipe.dietary && recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n    }\n    if (filters.difficulty) {\n      filteredRecipes = filteredRecipes.filter(recipe => recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase());\n    }\n    if (filters.maxCookingTime) {\n      const maxTime = parseInt(filters.maxCookingTime);\n      filteredRecipes = filteredRecipes.filter(recipe => recipe.cookingTime && recipe.cookingTime <= maxTime);\n    }\n    if (filters.maxCalories) {\n      const maxCals = parseInt(filters.maxCalories);\n      filteredRecipes = filteredRecipes.filter(recipe => recipe.nutrition && recipe.nutrition.calories <= maxCals);\n    }\n    if (filters.cuisine) {\n      filteredRecipes = filteredRecipes.filter(recipe => recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase()));\n    }\n    return {\n      recipes: filteredRecipes,\n      total: filteredRecipes.length\n    };\n  }\n  async searchWithFilters(ingredients = [], filters = {}) {\n    await this.loadRecipes();\n    let results = [...this.recipes];\n    if (ingredients && ingredients.length > 0) {\n      const searchTerms = ingredients.map(ing => ing.toLowerCase());\n      results = results.filter(recipe => {\n        const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n        return searchTerms.some(term => recipeIngredients.some(ing => ing.includes(term)));\n      });\n    }\n    if (filters.dietary && filters.dietary.length > 0) {\n      results = results.filter(recipe => filters.dietary.some(diet => recipe.dietary && recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n    }\n    if (filters.difficulty) {\n      results = results.filter(recipe => recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase());\n    }\n    if (filters.maxCookingTime) {\n      const maxTime = parseInt(filters.maxCookingTime);\n      results = results.filter(recipe => recipe.cookingTime && recipe.cookingTime <= maxTime);\n    }\n    if (filters.maxCalories) {\n      const maxCals = parseInt(filters.maxCalories);\n      results = results.filter(recipe => recipe.nutrition && recipe.nutrition.calories <= maxCals);\n    }\n    if (filters.cuisine) {\n      results = results.filter(recipe => recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase()));\n    }\n    return {\n      recipes: results,\n      total: results.length\n    };\n  }\n}\nexport const recipeService = new RecipeService();","map":{"version":3,"names":["axios","RecipeService","constructor","recipes","loadRecipes","length","response","get","data","error","console","getAllRecipes","limit","page","startIndex","slice","total","totalPages","Math","ceil","getRecipeById","id","recipe","find","r","parseInt","Error","searchByIngredients","ingredients","exactMatch","searchTerms","map","ing","toLowerCase","matchedRecipes","filter","recipeIngredients","name","every","term","some","includes","filterRecipes","filters","filteredRecipes","dietary","diet","recipeDiet","difficulty","maxCookingTime","maxTime","cookingTime","maxCalories","maxCals","nutrition","calories","cuisine","searchWithFilters","results","recipeService"],"sources":["C:/Users/singh/OneDrive/Desktop/daffodil/smart-recipe-generator/frontend/src/services/recipeService.js"],"sourcesContent":["import axios from 'axios';\n\nclass RecipeService {\n  constructor() {\n    this.recipes = [];\n  }\n\n  async loadRecipes() {\n    if (this.recipes.length === 0) {\n      try {\n        const response = await axios.get('/recipes.json');\n        this.recipes = response.data.recipes || [];\n      } catch (error) {\n        console.error('Error loading recipes:', error);\n        this.recipes = [];\n      }\n    }\n  }\n\n  async getAllRecipes(limit = null, page = 1) {\n    await this.loadRecipes();\n    let recipes = [...this.recipes];\n    if (limit) {\n      const startIndex = (page - 1) * limit;\n      recipes = recipes.slice(startIndex, startIndex + limit);\n    }\n    return {\n      recipes,\n      total: this.recipes.length,\n      page,\n      totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1,\n    };\n  }\n\n  async getRecipeById(id) {\n    await this.loadRecipes();\n    const recipe = this.recipes.find((r) => r.id === parseInt(id));\n    if (!recipe) {\n      throw new Error('Recipe not found');\n    }\n    return { recipe };\n  }\n\n  async searchByIngredients(ingredients, exactMatch = false) {\n    await this.loadRecipes();\n    const searchTerms = ingredients.map((ing) => ing.toLowerCase());\n    const matchedRecipes = this.recipes.filter((recipe) => {\n      const recipeIngredients = recipe.ingredients.map((ing) =>\n        ing.name.toLowerCase()\n      );\n      if (exactMatch) {\n        return searchTerms.every((term) =>\n          recipeIngredients.some((ing) => ing.includes(term))\n        );\n      } else {\n        return searchTerms.some((term) =>\n          recipeIngredients.some((ing) => ing.includes(term))\n        );\n      }\n    });\n    return {\n      recipes: matchedRecipes,\n      total: matchedRecipes.length,\n    };\n  }\n\n  async filterRecipes(filters) {\n    await this.loadRecipes();\n    let filteredRecipes = [...this.recipes];\n    // ... (rest of the filtering logic is the same as before)\n    if (filters.dietary && filters.dietary.length > 0) {\n        filteredRecipes = filteredRecipes.filter(recipe =>\n          filters.dietary.some(diet =>\n            recipe.dietary && recipe.dietary.some(recipeDiet =>\n              recipeDiet.toLowerCase() === diet.toLowerCase()\n            )\n          )\n        );\n      }\n      if (filters.difficulty) {\n        filteredRecipes = filteredRecipes.filter(recipe =>\n          recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase()\n        );\n      }\n      if (filters.maxCookingTime) {\n        const maxTime = parseInt(filters.maxCookingTime);\n        filteredRecipes = filteredRecipes.filter(recipe =>\n          recipe.cookingTime && recipe.cookingTime <= maxTime\n        );\n      }\n      if (filters.maxCalories) {\n        const maxCals = parseInt(filters.maxCalories);\n        filteredRecipes = filteredRecipes.filter(recipe =>\n          recipe.nutrition && recipe.nutrition.calories <= maxCals\n        );\n      }\n      if (filters.cuisine) {\n        filteredRecipes = filteredRecipes.filter(recipe =>\n          recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase())\n        );\n      }\n    return {\n      recipes: filteredRecipes,\n      total: filteredRecipes.length,\n    };\n  }\n\n    async searchWithFilters(ingredients = [], filters = {}) {\n    await this.loadRecipes();\n    let results = [...this.recipes];\n    if (ingredients && ingredients.length > 0) {\n      const searchTerms = ingredients.map((ing) => ing.toLowerCase());\n      results = results.filter((recipe) => {\n        const recipeIngredients = recipe.ingredients.map((ing) =>\n          ing.name.toLowerCase()\n        );\n        return searchTerms.some((term) =>\n          recipeIngredients.some((ing) => ing.includes(term))\n        );\n      });\n    }\n    if (filters.dietary && filters.dietary.length > 0) {\n        results = results.filter(recipe =>\n          filters.dietary.some(diet =>\n            recipe.dietary && recipe.dietary.some(recipeDiet =>\n              recipeDiet.toLowerCase() === diet.toLowerCase()\n            )\n          )\n        );\n      }\n      if (filters.difficulty) {\n        results = results.filter(recipe =>\n          recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase()\n        );\n      }\n      if (filters.maxCookingTime) {\n        const maxTime = parseInt(filters.maxCookingTime);\n        results = results.filter(recipe =>\n          recipe.cookingTime && recipe.cookingTime <= maxTime\n        );\n      }\n      if (filters.maxCalories) {\n        const maxCals = parseInt(filters.maxCalories);\n        results = results.filter(recipe =>\n          recipe.nutrition && recipe.nutrition.calories <= maxCals\n        );\n      }\n      if (filters.cuisine) {\n        results = results.filter(recipe =>\n          recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase())\n        );\n      }\n    return {\n      recipes: results,\n      total: results.length,\n    };\n  }\n}\n\nexport const recipeService = new RecipeService();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}