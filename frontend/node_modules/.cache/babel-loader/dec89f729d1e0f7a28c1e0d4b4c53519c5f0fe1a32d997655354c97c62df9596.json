{"ast":null,"code":"// Import the local recipes data\nimport recipesData from '../database/recipes.json';\nclass RecipeService {\n  constructor() {\n    this.recipes = recipesData.recipes || [];\n  }\n  async getAllRecipes(limit = null, page = 1) {\n    try {\n      let recipes = [...this.recipes];\n      if (limit) {\n        const startIndex = (page - 1) * limit;\n        recipes = recipes.slice(startIndex, startIndex + limit);\n      }\n      return {\n        recipes,\n        total: this.recipes.length,\n        page,\n        totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1\n      };\n    } catch (error) {\n      console.error('Error fetching recipes:', error);\n      throw new Error('Failed to fetch recipes');\n    }\n  }\n  async getRecipeById(id) {\n    try {\n      const recipe = this.recipes.find(r => r.id === parseInt(id));\n      if (!recipe) {\n        throw new Error('Recipe not found');\n      }\n      return {\n        recipe\n      };\n    } catch (error) {\n      console.error('Error fetching recipe:', error);\n      throw new Error('Failed to fetch recipe');\n    }\n  }\n  async searchByIngredients(ingredients, exactMatch = false) {\n    try {\n      const searchTerms = ingredients.map(ing => ing.toLowerCase());\n      const matchedRecipes = this.recipes.filter(recipe => {\n        const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n        if (exactMatch) {\n          return searchTerms.every(term => recipeIngredients.some(ing => ing.includes(term)));\n        } else {\n          return searchTerms.some(term => recipeIngredients.some(ing => ing.includes(term)));\n        }\n      });\n      return {\n        recipes: matchedRecipes,\n        total: matchedRecipes.length\n      };\n    } catch (error) {\n      console.error('Error searching recipes:', error);\n      throw new Error('Failed to search recipes');\n    }\n  }\n  async filterRecipes(filters) {\n    try {\n      let filteredRecipes = [...this.recipes];\n\n      // Filter by dietary preferences\n      if (filters.dietary && filters.dietary.length > 0) {\n        filteredRecipes = filteredRecipes.filter(recipe => filters.dietary.some(diet => recipe.dietary && recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n      }\n\n      // Filter by difficulty\n      if (filters.difficulty) {\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase());\n      }\n\n      // Filter by max cooking time\n      if (filters.maxCookingTime) {\n        const maxTime = parseInt(filters.maxCookingTime);\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.cookingTime && recipe.cookingTime <= maxTime);\n      }\n\n      // Filter by max calories\n      if (filters.maxCalories) {\n        const maxCals = parseInt(filters.maxCalories);\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.nutrition && recipe.nutrition.calories <= maxCals);\n      }\n\n      // Filter by cuisine\n      if (filters.cuisine) {\n        filteredRecipes = filteredRecipes.filter(recipe => recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase()));\n      }\n      return {\n        recipes: filteredRecipes,\n        total: filteredRecipes.length\n      };\n    } catch (error) {\n      console.error('Error filtering recipes:', error);\n      throw new Error('Failed to filter recipes');\n    }\n  }\n  async rateRecipe(recipeId, rating, userId = 'anonymous') {\n    try {\n      // Local implementation - find recipe and update rating\n      const recipeIndex = this.recipes.findIndex(r => r.id === parseInt(recipeId));\n      if (recipeIndex === -1) {\n        throw new Error('Recipe not found');\n      }\n\n      // Initialize ratings if not present\n      if (!this.recipes[recipeIndex].ratings) {\n        this.recipes[recipeIndex].ratings = [];\n        this.recipes[recipeIndex].totalRatings = 0;\n        this.recipes[recipeIndex].averageRating = 0;\n      }\n\n      // Add new rating\n      this.recipes[recipeIndex].ratings.push({\n        rating,\n        userId,\n        date: new Date()\n      });\n      this.recipes[recipeIndex].totalRatings = this.recipes[recipeIndex].ratings.length;\n\n      // Calculate new average\n      const sum = this.recipes[recipeIndex].ratings.reduce((acc, r) => acc + r.rating, 0);\n      this.recipes[recipeIndex].averageRating = sum / this.recipes[recipeIndex].totalRatings;\n      return {\n        success: true,\n        newRating: this.recipes[recipeIndex].averageRating\n      };\n    } catch (error) {\n      console.error('Error rating recipe:', error);\n      throw new Error('Failed to rate recipe');\n    }\n  }\n  async getRecommendations(availableIngredients = [], dietaryPreferences = [], limit = 5) {\n    try {\n      // Local implementation - recommend recipes based on ingredients and dietary preferences\n      let recommendations = this.recipes;\n      if (availableIngredients.length > 0) {\n        recommendations = recommendations.filter(recipe => {\n          const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n          return availableIngredients.some(ingredient => recipeIngredients.some(recIng => recIng.includes(ingredient.toLowerCase())));\n        });\n      }\n      if (dietaryPreferences.length > 0) {\n        recommendations = recommendations.filter(recipe => recipe.dietary && dietaryPreferences.some(diet => recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n      }\n\n      // Sort by rating and limit\n      recommendations.sort((a, b) => (b.averageRating || 0) - (a.averageRating || 0));\n      return {\n        recipes: recommendations.slice(0, limit),\n        total: recommendations.length\n      };\n    } catch (error) {\n      console.error('Error getting recommendations:', error);\n      throw new Error('Failed to get recommendations');\n    }\n  }\n  async getIngredientSuggestions(input) {\n    try {\n      // Local implementation - suggest ingredients from existing recipes\n      if (!input || input.length < 2) {\n        return {\n          suggestions: []\n        };\n      }\n      const allIngredients = new Set();\n      this.recipes.forEach(recipe => {\n        recipe.ingredients.forEach(ingredient => {\n          allIngredients.add(ingredient.name.toLowerCase());\n        });\n      });\n      const suggestions = Array.from(allIngredients).filter(ingredient => ingredient.includes(input.toLowerCase())).slice(0, 10);\n      return {\n        suggestions\n      };\n    } catch (error) {\n      console.error('Error getting ingredient suggestions:', error);\n      return {\n        suggestions: []\n      };\n    }\n  }\n\n  // New method to search with combined filters and ingredients\n  async searchWithFilters(ingredients = [], filters = {}) {\n    try {\n      let results = [...this.recipes];\n\n      // First filter by ingredients if provided\n      if (ingredients && ingredients.length > 0) {\n        const searchTerms = ingredients.map(ing => ing.toLowerCase());\n        results = results.filter(recipe => {\n          const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\n          return searchTerms.some(term => recipeIngredients.some(ing => ing.includes(term)));\n        });\n      }\n\n      // Then apply additional filters\n      if (filters.dietary && filters.dietary.length > 0) {\n        results = results.filter(recipe => filters.dietary.some(diet => recipe.dietary && recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())));\n      }\n      if (filters.difficulty) {\n        results = results.filter(recipe => recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase());\n      }\n      if (filters.maxCookingTime) {\n        const maxTime = parseInt(filters.maxCookingTime);\n        results = results.filter(recipe => recipe.cookingTime && recipe.cookingTime <= maxTime);\n      }\n      if (filters.maxCalories) {\n        const maxCals = parseInt(filters.maxCalories);\n        results = results.filter(recipe => recipe.nutrition && recipe.nutrition.calories <= maxCals);\n      }\n      if (filters.cuisine) {\n        results = results.filter(recipe => recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase()));\n      }\n      return {\n        recipes: results,\n        total: results.length\n      };\n    } catch (error) {\n      console.error('Error searching with filters:', error);\n      throw new Error('Failed to search recipes');\n    }\n  }\n}\nexport const recipeService = new RecipeService();","map":{"version":3,"names":["recipesData","RecipeService","constructor","recipes","getAllRecipes","limit","page","startIndex","slice","total","length","totalPages","Math","ceil","error","console","Error","getRecipeById","id","recipe","find","r","parseInt","searchByIngredients","ingredients","exactMatch","searchTerms","map","ing","toLowerCase","matchedRecipes","filter","recipeIngredients","name","every","term","some","includes","filterRecipes","filters","filteredRecipes","dietary","diet","recipeDiet","difficulty","maxCookingTime","maxTime","cookingTime","maxCalories","maxCals","nutrition","calories","cuisine","rateRecipe","recipeId","rating","userId","recipeIndex","findIndex","ratings","totalRatings","averageRating","push","date","Date","sum","reduce","acc","success","newRating","getRecommendations","availableIngredients","dietaryPreferences","recommendations","ingredient","recIng","sort","a","b","getIngredientSuggestions","input","suggestions","allIngredients","Set","forEach","add","Array","from","searchWithFilters","results","recipeService"],"sources":["C:/Users/singh/OneDrive/Desktop/daffodil/smart-recipe-generator/frontend/src/services/recipeService.js"],"sourcesContent":["// Import the local recipes data\r\nimport recipesData from '../database/recipes.json';\r\n\r\nclass RecipeService {\r\n  constructor() {\r\n    this.recipes = recipesData.recipes || [];\r\n  }\r\n\r\n  async getAllRecipes(limit = null, page = 1) {\r\n    try {\r\n      let recipes = [...this.recipes];\r\n      \r\n      if (limit) {\r\n        const startIndex = (page - 1) * limit;\r\n        recipes = recipes.slice(startIndex, startIndex + limit);\r\n      }\r\n      \r\n      return {\r\n        recipes,\r\n        total: this.recipes.length,\r\n        page,\r\n        totalPages: limit ? Math.ceil(this.recipes.length / limit) : 1\r\n      };\r\n    } catch (error) {\r\n      console.error('Error fetching recipes:', error);\r\n      throw new Error('Failed to fetch recipes');\r\n    }\r\n  }\r\n\r\n  async getRecipeById(id) {\r\n    try {\r\n      const recipe = this.recipes.find(r => r.id === parseInt(id));\r\n      if (!recipe) {\r\n        throw new Error('Recipe not found');\r\n      }\r\n      return { recipe };\r\n    } catch (error) {\r\n      console.error('Error fetching recipe:', error);\r\n      throw new Error('Failed to fetch recipe');\r\n    }\r\n  }\r\n\r\n  async searchByIngredients(ingredients, exactMatch = false) {\r\n    try {\r\n      const searchTerms = ingredients.map(ing => ing.toLowerCase());\r\n      \r\n      const matchedRecipes = this.recipes.filter(recipe => {\r\n        const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\r\n        \r\n        if (exactMatch) {\r\n          return searchTerms.every(term => \r\n            recipeIngredients.some(ing => ing.includes(term))\r\n          );\r\n        } else {\r\n          return searchTerms.some(term => \r\n            recipeIngredients.some(ing => ing.includes(term))\r\n          );\r\n        }\r\n      });\r\n      \r\n      return {\r\n        recipes: matchedRecipes,\r\n        total: matchedRecipes.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error searching recipes:', error);\r\n      throw new Error('Failed to search recipes');\r\n    }\r\n  }\r\n\r\n  async filterRecipes(filters) {\r\n    try {\r\n      let filteredRecipes = [...this.recipes];\r\n      \r\n      // Filter by dietary preferences\r\n      if (filters.dietary && filters.dietary.length > 0) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          filters.dietary.some(diet => \r\n            recipe.dietary && recipe.dietary.some(recipeDiet => \r\n              recipeDiet.toLowerCase() === diet.toLowerCase()\r\n            )\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Filter by difficulty\r\n      if (filters.difficulty) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase()\r\n        );\r\n      }\r\n      \r\n      // Filter by max cooking time\r\n      if (filters.maxCookingTime) {\r\n        const maxTime = parseInt(filters.maxCookingTime);\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.cookingTime && recipe.cookingTime <= maxTime\r\n        );\r\n      }\r\n      \r\n      // Filter by max calories\r\n      if (filters.maxCalories) {\r\n        const maxCals = parseInt(filters.maxCalories);\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.nutrition && recipe.nutrition.calories <= maxCals\r\n        );\r\n      }\r\n      \r\n      // Filter by cuisine\r\n      if (filters.cuisine) {\r\n        filteredRecipes = filteredRecipes.filter(recipe => \r\n          recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase())\r\n        );\r\n      }\r\n      \r\n      return {\r\n        recipes: filteredRecipes,\r\n        total: filteredRecipes.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error filtering recipes:', error);\r\n      throw new Error('Failed to filter recipes');\r\n    }\r\n  }\r\n\r\n  async rateRecipe(recipeId, rating, userId = 'anonymous') {\r\n    try {\r\n      // Local implementation - find recipe and update rating\r\n      const recipeIndex = this.recipes.findIndex(r => r.id === parseInt(recipeId));\r\n      if (recipeIndex === -1) {\r\n        throw new Error('Recipe not found');\r\n      }\r\n      \r\n      // Initialize ratings if not present\r\n      if (!this.recipes[recipeIndex].ratings) {\r\n        this.recipes[recipeIndex].ratings = [];\r\n        this.recipes[recipeIndex].totalRatings = 0;\r\n        this.recipes[recipeIndex].averageRating = 0;\r\n      }\r\n      \r\n      // Add new rating\r\n      this.recipes[recipeIndex].ratings.push({ rating, userId, date: new Date() });\r\n      this.recipes[recipeIndex].totalRatings = this.recipes[recipeIndex].ratings.length;\r\n      \r\n      // Calculate new average\r\n      const sum = this.recipes[recipeIndex].ratings.reduce((acc, r) => acc + r.rating, 0);\r\n      this.recipes[recipeIndex].averageRating = sum / this.recipes[recipeIndex].totalRatings;\r\n      \r\n      return { success: true, newRating: this.recipes[recipeIndex].averageRating };\r\n    } catch (error) {\r\n      console.error('Error rating recipe:', error);\r\n      throw new Error('Failed to rate recipe');\r\n    }\r\n  }\r\n\r\n  async getRecommendations(availableIngredients = [], dietaryPreferences = [], limit = 5) {\r\n    try {\r\n      // Local implementation - recommend recipes based on ingredients and dietary preferences\r\n      let recommendations = this.recipes;\r\n      \r\n      if (availableIngredients.length > 0) {\r\n        recommendations = recommendations.filter(recipe => {\r\n          const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\r\n          return availableIngredients.some(ingredient => \r\n            recipeIngredients.some(recIng => recIng.includes(ingredient.toLowerCase()))\r\n          );\r\n        });\r\n      }\r\n      \r\n      if (dietaryPreferences.length > 0) {\r\n        recommendations = recommendations.filter(recipe => \r\n          recipe.dietary && dietaryPreferences.some(diet => \r\n            recipe.dietary.some(recipeDiet => recipeDiet.toLowerCase() === diet.toLowerCase())\r\n          )\r\n        );\r\n      }\r\n      \r\n      // Sort by rating and limit\r\n      recommendations.sort((a, b) => (b.averageRating || 0) - (a.averageRating || 0));\r\n      \r\n      return {\r\n        recipes: recommendations.slice(0, limit),\r\n        total: recommendations.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error getting recommendations:', error);\r\n      throw new Error('Failed to get recommendations');\r\n    }\r\n  }\r\n\r\n  async getIngredientSuggestions(input) {\r\n    try {\r\n      // Local implementation - suggest ingredients from existing recipes\r\n      if (!input || input.length < 2) {\r\n        return { suggestions: [] };\r\n      }\r\n      \r\n      const allIngredients = new Set();\r\n      this.recipes.forEach(recipe => {\r\n        recipe.ingredients.forEach(ingredient => {\r\n          allIngredients.add(ingredient.name.toLowerCase());\r\n        });\r\n      });\r\n      \r\n      const suggestions = Array.from(allIngredients)\r\n        .filter(ingredient => ingredient.includes(input.toLowerCase()))\r\n        .slice(0, 10);\r\n      \r\n      return { suggestions };\r\n    } catch (error) {\r\n      console.error('Error getting ingredient suggestions:', error);\r\n      return { suggestions: [] };\r\n    }\r\n  }\r\n\r\n  // New method to search with combined filters and ingredients\r\n  async searchWithFilters(ingredients = [], filters = {}) {\r\n    try {\r\n      let results = [...this.recipes];\r\n      \r\n      // First filter by ingredients if provided\r\n      if (ingredients && ingredients.length > 0) {\r\n        const searchTerms = ingredients.map(ing => ing.toLowerCase());\r\n        results = results.filter(recipe => {\r\n          const recipeIngredients = recipe.ingredients.map(ing => ing.name.toLowerCase());\r\n          return searchTerms.some(term => \r\n            recipeIngredients.some(ing => ing.includes(term))\r\n          );\r\n        });\r\n      }\r\n      \r\n      // Then apply additional filters\r\n      if (filters.dietary && filters.dietary.length > 0) {\r\n        results = results.filter(recipe => \r\n          filters.dietary.some(diet => \r\n            recipe.dietary && recipe.dietary.some(recipeDiet => \r\n              recipeDiet.toLowerCase() === diet.toLowerCase()\r\n            )\r\n          )\r\n        );\r\n      }\r\n      \r\n      if (filters.difficulty) {\r\n        results = results.filter(recipe => \r\n          recipe.difficulty && recipe.difficulty.toLowerCase() === filters.difficulty.toLowerCase()\r\n        );\r\n      }\r\n      \r\n      if (filters.maxCookingTime) {\r\n        const maxTime = parseInt(filters.maxCookingTime);\r\n        results = results.filter(recipe => \r\n          recipe.cookingTime && recipe.cookingTime <= maxTime\r\n        );\r\n      }\r\n      \r\n      if (filters.maxCalories) {\r\n        const maxCals = parseInt(filters.maxCalories);\r\n        results = results.filter(recipe => \r\n          recipe.nutrition && recipe.nutrition.calories <= maxCals\r\n        );\r\n      }\r\n      \r\n      if (filters.cuisine) {\r\n        results = results.filter(recipe => \r\n          recipe.cuisine && recipe.cuisine.toLowerCase().includes(filters.cuisine.toLowerCase())\r\n        );\r\n      }\r\n      \r\n      return {\r\n        recipes: results,\r\n        total: results.length\r\n      };\r\n    } catch (error) {\r\n      console.error('Error searching with filters:', error);\r\n      throw new Error('Failed to search recipes');\r\n    }\r\n  }\r\n}\r\n\r\nexport const recipeService = new RecipeService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}